package main

import (
	"net"
	"strings"
)

/*Dr. Muller:
Have your Ambassador function take the first message and determine what kind of client you're dealing with.

Method: Capture transient first-message. If something expected, then handle as expected, otherwise, flag it as an exception, log it, leave.

Note: If you need to add a preamble message to a protocol so that we know who we're talking to, then it's not bloat. Just do it.

If you're trying to put a message in a byte string, then try to read the whole message in [size of buffer] bytes. If you don't have all the bytes in the message,
then read the rest of the buffer again.

must determine when to stop reading a message. Must know length or terminal character or something.

General Strategy (Covered in Stevens): how to encapsulate message in byte string
*/

//handles requests for the main
func Ambassador(conn net.Conn) {
	var msg Netmessage
	var err error
	Errhandle_Log(err, ERRMSG_TCPLISTENER)
	if err != nil {
		return
	}
	err = ReceiveStruct(&msg, conn)
	Errhandle_Log(err, ERRMSG_NETWORK_RECEIVE_STRUCT)
	if err != nil {
		return
	}
	switch msg.Message {
	case NETREQ_NEWDEVICE:
		RequestDevice(conn)
	case NETREQ_NEWDEVICE_JAVASCRIPT:
		RequestDevice_Javascript(conn)
	default:
		conn.Close()
	}
}

func ClientIdentifier(conn net.Conn) *string {
	var length int
	var initialmessage []byte = make([]byte, 1024)
	var msgstring string
	var err error

	length, err = conn.Read(initialmessage)

}

//Request to add/register device.
func RequestDevice(conn net.Conn) (Device, error) {
	var retdevice Device
	var ipstring string
	var ip net.IP
	var cdinf DeviceInfo
	var msg Netmessage
	var err error

	msg = NewNetmessage(NETREQ_NEWDEVICE)
	err = SendStruct(&msg, conn)
	Errhandle_Log(err, ERRMSG_NETWORK_SEND_STRUCT)
	if err != nil {
		return retdevice, err
	}
	err = ReceiveStruct(&cdinf, conn)
	Errhandle_Log(err, ERRMSG_NETWORK_RECEIVE_STRUCT)
	if err != nil {
		return retdevice, err
	}
	ipstring = strings.Split(conn.RemoteAddr().String(), ":")[0]
	ip = net.ParseIP(ipstring)
	retdevice, err = NewDevice(cdinf.Userid, cdinf.Devicename, ip)
	Errhandle_Log(err, ERRMSG_CREATE_DEVICE)
	err = SendStruct(&retdevice, conn)
	Errhandle_Log(err, ERRMSG_NETWORK_SEND_STRUCT)
	//return or return, because we can't return a nil device
	return retdevice, err
}

func RequestDevice_Javascript(conn net.Conn) (Device, error) {
	var msg Netmessage
	var retdevice Device
	var err error
	var cdinf DeviceInfo
	var ip net.IP
	var ipstring string

	msg = NewNetmessage(NETREQ_NEWDEVICE_JAVASCRIPT)
	err = SendStruct_JSClient(&msg, conn)
	Errhandle_Log(err, ERRMSG_NETWORK_SEND_STRUCT)
	if err != nil {
		return retdevice, err
	}
	err = ReceiveStruct_JSClient(&cdinf, conn)
	if err != nil {
		return retdevice, err
	}
	ipstring = strings.Split(conn.RemoteAddr().String(), ":")[0]
	ip = net.ParseIP(ipstring)
	retdevice, err = NewDevice(cdinf.Userid, cdinf.Devicename, ip)
	Errhandle_Log(err, ERRMSG_CREATE_DEVICE)
	err = SendStruct_JSClient(&retdevice, conn)
	Errhandle_Log(err, ERRMSG_NETWORK_SEND_STRUCT)
	//return or return, because we can't return a nil device
	return retdevice, err
}
